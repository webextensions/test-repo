/* eslint-env node */

var path = require('path'),
    fs = require('fs');

var semver = require('./utils/3rdparty/semver.js');

var generateStakeholdersHash = require('./utils/generateHashFromStakeholders.js');

var { spawn, exec } = require('./utils/run-command.js');

var lockedVersionsSatisfy = function (intendedDependencies, installedDependencies) {
    var allVersionsSatisfied = Object.keys(intendedDependencies).every(function (key) {
        var intendedDependency = intendedDependencies[key],
            installedDependency = installedDependencies[key];
        if (installedDependency && semver.satisfies(installedDependency.version, intendedDependency)) {
            return true;
        } else {
            return false;
        }
    });
    return allVersionsSatisfied;
};

var arePackageJsonAndPackageLockJsonInSync = function (projectRoot) {
    var packageJson;
    try { packageJson = require(path.resolve(projectRoot, 'package.json')); } catch (e) { /* do nothing */ }

    var packageLockJson;
    try { packageLockJson = require(path.resolve(projectRoot, 'package-lock.json')); } catch (e) { /* do nothing */ }

    if (!packageJson) {
        console.error('Error: package.json is not available or it is invalid');
        process.exit(1);
    }
    if (!packageLockJson) {
        console.error('Error: package-lock.json is not available or it is invalid');
        process.exit(1);
    }

    var flagLockedVersionsInSync =
            lockedVersionsSatisfy(packageJson.dependencies, packageLockJson.dependencies) &&
            lockedVersionsSatisfy(packageJson.devDependencies, packageLockJson.dependencies);

    return flagLockedVersionsInSync;
};

var quickInstall = async function (options) {
    var {
        argv,
        projectRoot,
        archiveFolder,
        showDiskSpaceWarningBelow
    } = options;
    argv = argv || [];
    var passedArguments = {};

    argv.forEach(function (val, index) {
        if (index >= 2) {
            passedArguments[val] = val;
        }
    });

    var spawnWrtProjectRoot = async function (app, params) {
        var cwd = projectRoot,
            exitCode = await spawn(app, params, { cwd });
        console.log('Exit code: ' + exitCode);
        return exitCode;
    };

    var backupNodeModulesIfRequired = async function (nodeModulesBackupFilePath) {
        if (!fs.existsSync(nodeModulesBackupFilePath)) {
            var directoryPath = path.dirname(nodeModulesBackupFilePath);
            var exitCode;
            exitCode = await spawnWrtProjectRoot('sh', ['-c', 'mkdir -p ' + directoryPath]);
            if (exitCode) {
                return exitCode;
            } else {
                // https://stackoverflow.com/questions/38273253/using-two-commands-using-pipe-with-spawn/38273497#38273497
                exitCode = await spawnWrtProjectRoot('sh', ['-c', 'tar cf - node_modules | gzip -6 - > ' + nodeModulesBackupFilePath]);
                if (exitCode) {
                    return exitCode;
                }
            }
        }
        return 0;
    };

    var restoreNodeModulesFromBackup = async function (nodeModulesBackupFilePath, archiveFolder) {
        var directoryName = path.basename(nodeModulesBackupFilePath).split('.tar.gz')[0],
            directoryPathWrtProjectRoot = path.resolve(archiveFolder, directoryName);

        await spawnWrtProjectRoot('sh', ['-c', 'mkdir -p "' + directoryPathWrtProjectRoot + '"']);
        await spawnWrtProjectRoot('sh', ['-c', 'tar -xzf "' + nodeModulesBackupFilePath + '" --directory "' + directoryPathWrtProjectRoot + '"']);

        // TODO: Rather than removing node_modules, rename that folder to some temporary name
        //       and once the next step of moving the restored node_modules is done, then
        //       remove the folder
        await spawnWrtProjectRoot('sh', ['-c', 'rm -rf node_modules']);
        await spawnWrtProjectRoot('sh', ['-c', 'mv "' + directoryPathWrtProjectRoot + '/node_modules" ./']);

        await spawnWrtProjectRoot('sh', ['-c', 'rm -rf "' + directoryPathWrtProjectRoot + '"']);
    };

    var fileExistsRelativeToProjectRoot = function (file) {
        var resolvedPath = path.resolve(projectRoot, file);
        return fs.existsSync(resolvedPath);
    };

    var getNodeModulesBackupFilePath = async function (options) {
        var { projectRoot, archiveFolder } = options;
        var stakeholdersHash = await generateStakeholdersHash({projectRoot}),
            nodeModulesBackupFilePath = path.resolve(projectRoot, archiveFolder, 'node_modules-' + stakeholdersHash + '.tar.gz');
        return nodeModulesBackupFilePath;
    };

    var nodeModulesBackupFilePath = await getNodeModulesBackupFilePath({projectRoot, archiveFolder});
    var warningOccurred = false;

    var exitWithError = function (msg) {
        if (msg) {
            console.log(msg);
        }
        console.log('\n ✗ Failure\n');
        process.exit(1);
    };

    var checkDiskSpaceOfPartitionForPath = async function (nodeModulesBackupFilePath) {
        // https://stackoverflow.com/questions/19703621/get-free-disk-space-with-df-to-just-display-free-space-in-kb/19703644#19703644
        var output = await exec(
            'sh',
            ['-c', 'df -B1 "' + nodeModulesBackupFilePath + '" | tail -1 | tr -s " " | cut -d" " -f4']
        );
        var textOutput = (output.stdout || '').trim();
        var exitCode = (output.err || {}).code || 0;
        console.log('Exit code: ' + exitCode);
        if (output.err) {
            console.log('Warning: Could not get free disk space for the partition where backup is expected to be stored');
            warningOccurred = true;
        }

        return textOutput;
    };
    var freePartitionSpaceInBytes = parseInt(await checkDiskSpaceOfPartitionForPath(nodeModulesBackupFilePath), 10);
    showDiskSpaceWarningBelow = showDiskSpaceWarningBelow || 10 * 1024 * 1024 * 1024;     // Default to 10GB
    if (freePartitionSpaceInBytes < showDiskSpaceWarningBelow) {
        console.warn('\nWarning: The available disk space for partition containing node_modules archive folder is less than ' + showDiskSpaceWarningBelow + ' bytes.\n');
        warningOccurred = true;
    }

    if (fileExistsRelativeToProjectRoot('package-lock.json')) {
        if (!arePackageJsonAndPackageLockJsonInSync(projectRoot)) {
            if (passedArguments['--package-lock-must-be-in-sync-when-available']) {
                exitWithError('Error: package-lock.json file is not in sync with package.json');
            }
            warningOccurred = true;
            console.warn('\nWarning: Your package-lock.json is out of sync with package.json\n');
        }
    } else {
        if (passedArguments['--must-have-package-lock']) {
            exitWithError('Error: package-lock.json file is missing');
        }
    }

    if (fs.existsSync(nodeModulesBackupFilePath)) {
        await restoreNodeModulesFromBackup(nodeModulesBackupFilePath, archiveFolder);
    } else {
        let exitCode;
        if (fileExistsRelativeToProjectRoot('package-lock.json')) {
            if (arePackageJsonAndPackageLockJsonInSync(projectRoot)) {
                exitCode = await spawnWrtProjectRoot('npm', ['ci']);
                if (exitCode !== 0) {
                    exitCode = await spawnWrtProjectRoot('npm', ['install', '--no-package-lock']);
                }
            } else {
                // We would have shown a warning about the fact that package.json and package.cjson are out of sync
                exitCode = await spawnWrtProjectRoot('npm', ['install']);
                if (exitCode === 0) {
                    // Update nodeModulesBackupFilePath since the "stakeholder" package-lock.json might have changed have changed
                    nodeModulesBackupFilePath = await getNodeModulesBackupFilePath({projectRoot, archiveFolder});
                } else {
                    exitCode = await spawnWrtProjectRoot('npm', ['install', '--no-package-lock']);
                    if (exitCode !== 0) {
                        exitCode = await spawnWrtProjectRoot('npm', ['ci']);
                    }
                }
            }
        } else {
            exitCode = await spawnWrtProjectRoot('npm', ['install', '--no-package-lock']);
        }

        if (exitCode === 0) {
            exitCode = await backupNodeModulesIfRequired(nodeModulesBackupFilePath);
            if (exitCode) {
                warningOccurred = true;
                console.log('Warning: Could not backup the node_modules contents.');
            }
        } else {
            exitWithError('Error: Could not run npm installation.');
        }
    }

    console.log('');
    if (warningOccurred) {
        console.log(' ? Please note the warning(s) mentioned above.');
    }
    console.log(' ✓ Success\n');
};

module.exports = quickInstall;
