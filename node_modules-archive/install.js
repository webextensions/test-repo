#!/usr/bin/env node

/*
TODO:
    Apply one or more of the following approaches.

    Add check for low disk space (on current partition).
        $ df -k . | tail -1 | tr -s ' ' | cut -d' ' -f4
        https://stackoverflow.com/questions/19703621/get-free-disk-space-with-df-to-just-display-free-space-in-kb/19703644#19703644

        - If the free disk space nears a threshold
            - Show low disk space warning
        - If the free disk space crosses danger level threshold
            - Show a severe warning to the user
            - Stop using the node_modules backup feature
            - Automatically clear the oldest node_modules backups which have not been touched/created recently

    If the number of node_modules backups crosses a threshold.
        - Show a warning/info to the user
        - Automatically clear the oldest node_modules backups which have not been touched/created recently
*/

var path = require('path'),
    fs = require('fs');

var semver = require('./utils/3rdparty/semver.js');

var {
    spawn,
    exec,
    awaitableExec
} = require('./utils/run-command.js');

var restoreNodeModulesFromBackupWithHash = function () {
    spawn('Extract files from tar.gz');
};

var fileExistsRelativeToProjectRoot = function (file) {
    var resolvedPath = path.resolve(__dirname, '..', file);
    return fs.existsSync(resolvedPath);
};

var lockedVersionsVerify = function (intendedDependencies, installedDependencies) {
    var allVersionsSatisfied = Object.keys(intendedDependencies).every(function (key) {
        var intendedDependency = intendedDependencies[key],
            installedDependency = installedDependencies[key];
        if (installedDependency && semver.satisfies(installedDependency.version, intendedDependency)) {
            return true;
        } else {
            return false;
        }
    });
    return allVersionsSatisfied;
};

var arePackageJsonAndPackageLockJsonInSync = function () {
    var packageJson;
    try { packageJson = require('../package.json'); } catch (e) { /* do nothing */ }

    var packageLockJson;
    try { packageLockJson = require('../package-lock.json'); } catch (e) { /* do nothing */ }

    if (!packageJson) {
        logger.fatal('Error: package.json is not available or it is invalid');
        process.exit(1);
    }
    if (!packageLockJson) {
        logger.fatal('Error: package-lock.json is not available or it is invalid');
        process.exit(1);
    }

    var flagLockedVersionsInSync =
            lockedVersionsVerify(packageJson.dependencies, packageLockJson.dependencies) &&
            lockedVersionsVerify(packageJson.devDependencies, packageLockJson.dependencies);

    return flagLockedVersionsInSync;
};

var backupNodeModulesIfRequired = async function (nodeModulesBackupFilePath) {
    if (!fs.existsSync(nodeModulesBackupFilePath)) {
        // https://stackoverflow.com/questions/38273253/using-two-commands-using-pipe-with-spawn/38273497#38273497
        await spawnWrtProjectRoot('sh', ['-c', 'tar cf - node_modules | gzip -6 - > ' + nodeModulesBackupFilePath]);
    }
};

var restoreNodeModulesFromBackup = async function (nodeModulesBackupFilePath) {
    var directoryName = path.basename(nodeModulesBackupFilePath).split('.tar.gz')[0],
        directoryPathWrtProjectRoot = 'node_modules-archive/archive/' + directoryName;

    // https://stackoverflow.com/questions/38273253/using-two-commands-using-pipe-with-spawn/38273497#38273497
    await spawnWrtProjectRoot('sh', ['-c', 'mkdir -p ' + directoryPathWrtProjectRoot]);
    await spawnWrtProjectRoot('sh', ['-c', 'tar -xzf ' + nodeModulesBackupFilePath + ' --directory ' + directoryPathWrtProjectRoot]);
    await spawnWrtProjectRoot('sh', ['-c', 'rm -rf node_modules']);
    await spawnWrtProjectRoot('sh', ['-c', 'mv ' + directoryPathWrtProjectRoot + '/node_modules ./']);
    await spawnWrtProjectRoot('sh', ['-c', 'rm -rf ' + directoryPathWrtProjectRoot]);
};

var spawnWrtProjectRoot = async function (app, params) {
    var cwd = path.resolve(__dirname, '..'),
        exitCode = await spawn(app, params, { cwd });
    console.log('Exit code: ' + exitCode);
    return exitCode;
};

var generateStakeholdersHash = require('./utils/generateHashFromStakeholders.js');
var main = async function () {
    var stakeholdersHash = await generateStakeholdersHash(),
        nodeModulesBackupFilePath = path.resolve(__dirname, '..', 'node_modules-archive', 'archive', 'node_modules-' + stakeholdersHash + '.tar.gz');
    var errorOccurred = false;

    if (fs.existsSync(nodeModulesBackupFilePath)) {
        await restoreNodeModulesFromBackup(nodeModulesBackupFilePath);
    } else {
        var exitCode;
        if (fileExistsRelativeToProjectRoot('package-lock.json')) {
            if (arePackageJsonAndPackageLockJsonInSync()) {
                exitCode = await spawnWrtProjectRoot('npm', ['ci']);
                if (exitCode !== 0) {
                    exitCode = await spawnWrtProjectRoot('npm', ['install', '--no-package-lock']);
                }
            } else {
                console.warn('Warning: Your package-lock.json is out of sync with package.json');
                exitCode = spawnWrtProjectRoot('npm', ['install', '--no-package-lock']);
                if (exitCode !== 0) {
                    exitCode = await spawnWrtProjectRoot('npm', ['ci']);
                }
            }
        } else {
            exitCode = await spawnWrtProjectRoot('npm', ['install', '--no-package-lock']);
        }

        if (exitCode === 0) {
            await backupNodeModulesIfRequired(nodeModulesBackupFilePath);
        } else {
            errorOccurred = true;
            console.log('Error in npm installation.');
        }
    }

    if (errorOccurred) {
        console.log('\n ✗ Failure\n');
        process.exit(1);
    } else {
        console.log('\n ✓ Success\n');
    }
};
main();
